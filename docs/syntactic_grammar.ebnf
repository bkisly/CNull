(*Start symbol and essential elements*)

document                        = { import_directive }, { function_definition };
import_directive                = 'import', identifier, { '.', identifier }, ';';

(*Functions, methods and types*)

function_definition             = return_type, identifier, '(', [ parameter_list ], ')' block_statement;
parameter_list                  = parameter, { ',', parameter };
parameter                       = type_name, identifier;

block_statement                 = '{', { basic_statement }, '}';

return_type                     = 'void'
                                | type_name;

type_name                       = primitive_type
                                | dict_type
                                | identifier;

primitive_type                  = 'bool' | 'int' | 'char' | 'string' | 'float';
dict_type                       = 'dict', '<', type_name, ',', type_name, '>';

(*Statements*)

basic_statement                 = variable_declaration
                                | expression_statement
                                | if_statement
                                | while_statement
                                | try_statement
                                | jump_statement;

expression_statement            = expression, ';';

(*- Variables*)

variable_declaration            = type_name, identifier, ';'
                                | type_name, identifier, '=', non_assignment_expression, ';';

(*- If statement*)

if_statement                    = 'if', '(', expression, ')', block_statement,
                                [ 'else', ( if_statement | block_statement ) ];

(*- Loop statements*)

while_statement                 = 'while', '(', expression, ')', block_statement;

(*- Exceptions-related statements*)

try_statement                   = 'try', block_statement, catch_clause, { catch_clause };
catch_clause                    = 'catch', '(', identifier, [ identifier ], ')', block_statement;

jump_statement                  = 'continue', ';'
                                | 'break', ';'
                                | return_statement
                                | throw_expression, ';';
return_statement                = 'return', unary_expression, ';';

(*Expressions*)

expression                      = conditional_or_expression
                                | assignment;

assignment                      = unary_expression, assignment_operator, expression;
assignment_operator             = '=';

throw_expression                = 'throw', new_expression;

conditional_or_expression       = conditional_and_expression
                                | conditional_or_expression, '||', conditional_and_expression;
conditional_and_expression      = relational_expression
                                | conditional_and_expression, '&&', relational_expression;
relational_expression           = additive_expression
                                | additive_expression, '<', additive_expression
                                | additive_expression, '>', additive_expression
                                | additive_expression, '<=', additive_expression
                                | additive_expression, '>=', additive_expression
                                | additive_expression, '==', additive_expression
                                | additive_expression, '!=', additive_expression;

additive_expression             = multiplicative_expression
                                | additive_expression, '+', multiplicative_expression
                                | additive_expression, '-', multiplicative_expression;
multiplicative_expression       = unary_expression
                                | multiplicative_expression, '*', unary_expression
                                | multiplicative_expression, '/', unary_expression
                                | multiplicative_expression, '%', unary_expression;

unary_expression                = secondary_expression
                                | '+', unary_expression
                                | '-', unary_expression
                                | '!', unary_expression;

secondary_expression            = unary_expression, '?'
                                | primary_expression

primary_expression              = literal
                                | identifier
                                | parenthesised_expression
                                | member_access
                                | invocation_expression
                                | new_expression;

parenthesised_expression        = '(', expression, ')';

member_access                   = primary_expression, '.', identifier;
invocation_expression           = primary_expression, '(', [ argument_list ], ')';
argument_list                   = unary_expression, { unary_expression };

new_expression                  = type_name, [ '(', argument_list, ')' ];
